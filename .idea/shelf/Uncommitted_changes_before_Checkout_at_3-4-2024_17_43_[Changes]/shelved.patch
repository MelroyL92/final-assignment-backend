Index: src/main/java/nl/novi/finalAssignmentBackend/controllers/UserController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package nl.novi.finalAssignmentBackend.controllers;\r\n\r\nimport nl.novi.finalAssignmentBackend.Service.UserService;\r\nimport nl.novi.finalAssignmentBackend.dtos.user.UserDto;\r\nimport nl.novi.finalAssignmentBackend.exceptions.BadRequestException;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.*;\r\nimport org.springframework.web.servlet.support.ServletUriComponentsBuilder;\r\n\r\nimport java.net.URI;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n@CrossOrigin\r\n    @RestController\r\n    @RequestMapping(value = \"/users\")\r\n    public class UserController {\r\n\r\n        private final UserService userService;\r\n\r\n        public UserController(UserService userService) {\r\n            this.userService = userService;\r\n        }\r\n\r\n\r\n        @GetMapping(value = \"\")\r\n        public ResponseEntity<List<UserDto>> getUsers() {\r\n\r\n            List<UserDto> userDtos = userService.getUsers();\r\n\r\n            return ResponseEntity.ok().body(userDtos);\r\n        }\r\n\r\n        @GetMapping(value = \"/{username}\")\r\n        public ResponseEntity<UserDto> getUser(@PathVariable(\"username\") String username) {\r\n\r\n            UserDto optionalUser = userService.getUser(username);\r\n\r\n\r\n            return ResponseEntity.ok().body(optionalUser);\r\n\r\n        }\r\n\r\n        @PostMapping(value = \"\")\r\n        public ResponseEntity<UserDto> createCustomer(@RequestBody UserDto dto) {\r\n            ;\r\n\r\n            String newUsername = userService.createUser(dto);\r\n            userService.addAuthority(newUsername, \"ROLE_USER\");\r\n\r\n            URI location = ServletUriComponentsBuilder.fromCurrentRequest().path(\"/{username}\")\r\n                    .buildAndExpand(newUsername).toUri();\r\n\r\n            return ResponseEntity.created(location).build();\r\n        }\r\n\r\n        @PutMapping(value = \"/{username}\")\r\n        public ResponseEntity<UserDto> updateCustomer(@PathVariable(\"username\") String username, @RequestBody UserDto dto) {\r\n\r\n            userService.updateUser(username, dto);\r\n\r\n            return ResponseEntity.noContent().build();\r\n        }\r\n\r\n        @DeleteMapping(value = \"/{username}\")\r\n        public ResponseEntity<Object> deleteCustomer(@PathVariable(\"username\") String username) {\r\n            userService.deleteUser(username);\r\n            return ResponseEntity.noContent().build();\r\n        }\r\n\r\n        @GetMapping(value = \"/{username}/authorities\")\r\n        public ResponseEntity<Object> getUserAuthorities(@PathVariable(\"username\") String username) {\r\n            return ResponseEntity.ok().body(userService.getAuthorities(username));\r\n        }\r\n\r\n        //TODO: Als Requestbody wordt hier een Map<String, Object> gebruikt om de \"authorityName\" binnen te halen, dat werkt, maar kun je een beter oplossing bedenken?\r\n        @PostMapping(value = \"/{username}/authorities\")\r\n        public ResponseEntity<Object> addUserAuthority(@PathVariable(\"username\") String username, @RequestBody Map<String, Object> fields) {\r\n            try {\r\n                String authorityName = (String) fields.get(\"authority\");\r\n                userService.addAuthority(username, authorityName);\r\n                return ResponseEntity.noContent().build();\r\n            } catch (Exception ex) {\r\n                throw new BadRequestException();\r\n            }\r\n        }\r\n\r\n        @DeleteMapping(value = \"/{username}/authorities/{authority}\")\r\n        public ResponseEntity<Object> deleteUserAuthority(@PathVariable(\"username\") String username, @PathVariable(\"authority\") String authority) {\r\n            userService.removeAuthority(username, authority);\r\n            return ResponseEntity.noContent().build();\r\n        }\r\n\r\n    }\r\n
===================================================================
diff --git a/src/main/java/nl/novi/finalAssignmentBackend/controllers/UserController.java b/src/main/java/nl/novi/finalAssignmentBackend/controllers/UserController.java
--- a/src/main/java/nl/novi/finalAssignmentBackend/controllers/UserController.java	
+++ b/src/main/java/nl/novi/finalAssignmentBackend/controllers/UserController.java	
@@ -36,7 +36,6 @@
 
             UserDto optionalUser = userService.getUser(username);
 
-
             return ResponseEntity.ok().body(optionalUser);
 
         }
Index: src/main/java/nl/novi/finalAssignmentBackend/config/SpringSecurityConfig.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package nl.novi.finalAssignmentBackend.config;\r\n\r\n\r\nimport nl.novi.finalAssignmentBackend.Service.CustomUserDetailsService;\r\nimport nl.novi.finalAssignmentBackend.filter.JwtRequestFilter;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.http.HttpMethod;\r\nimport org.springframework.security.authentication.AuthenticationManager;\r\nimport org.springframework.security.authentication.ProviderManager;\r\nimport org.springframework.security.authentication.dao.DaoAuthenticationProvider;\r\nimport org.springframework.security.config.Customizer;\r\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\r\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\r\nimport org.springframework.security.config.http.SessionCreationPolicy;\r\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\nimport org.springframework.security.web.SecurityFilterChain;\r\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\r\n\r\n@Configuration\r\n@EnableWebSecurity\r\npublic class SpringSecurityConfig {\r\n\r\n    private final CustomUserDetailsService customUserDetailsService;\r\n    private final JwtRequestFilter jwtRequestFilter;\r\n\r\n    public SpringSecurityConfig(CustomUserDetailsService customUserDetailsService, JwtRequestFilter jwtRequestFilter) {\r\n        this.customUserDetailsService = customUserDetailsService;\r\n        this.jwtRequestFilter = jwtRequestFilter;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    // Authenticatie met customUserDetailsService en passwordEncoder\r\n    @Bean\r\n    public AuthenticationManager authenticationManager(HttpSecurity http, PasswordEncoder passwordEncoder) throws Exception {\r\n        var auth = new DaoAuthenticationProvider();\r\n        auth.setPasswordEncoder(passwordEncoder);\r\n        auth.setUserDetailsService(customUserDetailsService);\r\n        return new ProviderManager(auth);\r\n    }\r\n\r\n\r\n\r\n    // Authorizatie met jwt\r\n    @Bean\r\n    protected SecurityFilterChain filter (HttpSecurity http) throws Exception {\r\n\r\n        //JWT token authentication\r\n        http\r\n                .csrf(csrf -> csrf.disable())\r\n                .httpBasic(basic -> basic.disable())\r\n                .cors(Customizer.withDefaults())\r\n                .authorizeHttpRequests(auth ->\r\n                        auth\r\n                                // Wanneer je deze uncomments, staat je hele security open. Je hebt dan alleen nog een jwt nodig.\r\n                .requestMatchers(\"/**\").permitAll()\r\n                .requestMatchers(HttpMethod.POST, \"/users\").hasRole(\"ADMIN\")\r\n                .requestMatchers(HttpMethod.GET,\"/users\").hasRole(\"ADMIN\")\r\n                .requestMatchers(HttpMethod.POST,\"/users/**\").hasRole(\"ADMIN\")\r\n                .requestMatchers(HttpMethod.DELETE, \"/users/**\").hasRole(\"ADMIN\")\r\n                /*TODO voeg de antmatchers toe voor admin(post en delete) en user (overige)*/\r\n                .requestMatchers(\"/authenticated\").authenticated()\r\n                .requestMatchers(\"/authenticate\").permitAll()/*alleen dit punt mag toegankelijk zijn voor niet ingelogde gebruikers*/\r\n                .anyRequest().denyAll() /*Deze voeg je altijd als laatste toe, om een default beveiliging te hebben voor eventuele vergeten endpoints of endpoints die je later toevoegd. */\r\n                )\r\n                .sessionManagement(sess -> sess.sessionCreationPolicy(SessionCreationPolicy.STATELESS));\r\n        http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);\r\n        return http.build();\r\n    }\r\n\r\n}
===================================================================
diff --git a/src/main/java/nl/novi/finalAssignmentBackend/config/SpringSecurityConfig.java b/src/main/java/nl/novi/finalAssignmentBackend/config/SpringSecurityConfig.java
--- a/src/main/java/nl/novi/finalAssignmentBackend/config/SpringSecurityConfig.java	
+++ b/src/main/java/nl/novi/finalAssignmentBackend/config/SpringSecurityConfig.java	
@@ -13,7 +13,6 @@
 import org.springframework.security.config.annotation.web.builders.HttpSecurity;
 import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
 import org.springframework.security.config.http.SessionCreationPolicy;
-import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
 import org.springframework.security.crypto.password.PasswordEncoder;
 import org.springframework.security.web.SecurityFilterChain;
 import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
